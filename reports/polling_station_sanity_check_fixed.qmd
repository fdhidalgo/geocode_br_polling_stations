---
title: "Brazilian Polling Station Data Quality Report (Fixed)"
subtitle: "Corrected Sanity Checks Using Municipality Codes"
author: "Pipeline Automated Report"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
    code-fold: true
    theme: cosmo
    fig-width: 10
    fig-height: 6
    self-contained: true
execute:
  echo: false
  warning: false
  message: false
---

```{r}
#| label: setup
#| include: false

# Load required libraries
library(data.table)
library(ggplot2)
library(DT)
library(knitr)
library(targets)

# Set ggplot theme
theme_set(theme_minimal(base_size = 12))

# Custom color palette
colors <- c(
  "good" = "#28a745",
  "warning" = "#ffc107", 
  "danger" = "#dc3545",
  "primary" = "#007bff",
  "secondary" = "#6c757d"
)
```

```{r}
#| label: load-data

# Load targets data
tryCatch({
  tar_load(c(panel_ids, geocoded_locais))
}, error = function(e) {
  # Fallback for manual execution
  project_root <- normalizePath(file.path(getwd(), ".."), mustWork = FALSE)
  tar_load(c(panel_ids, geocoded_locais), store = file.path(project_root, "_targets"))
})

# Basic statistics
total_stations <- uniqueN(geocoded_locais$local_id)
total_records <- nrow(geocoded_locais)
years_covered <- sort(unique(geocoded_locais$ano))
states_covered <- sort(unique(geocoded_locais$sg_uf))

# CRITICAL FIX: Count unique municipalities by code only
unique_municipalities <- uniqueN(geocoded_locais$cod_localidade_ibge)
```

## Executive Summary {.unnumbered}

::::: {.callout-note}
**Report Generated**: `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

**Data Coverage**: 
- Years: `r paste(range(years_covered), collapse = " - ")`
- States: `r ifelse(length(states_covered) > 5, paste0(length(states_covered), " states"), paste(states_covered, collapse = ", "))`
- Unique Municipalities: `r format(unique_municipalities, big.mark = ",")`
- Total Polling Stations: `r format(total_stations, big.mark = ",")`
- Total Records: `r format(total_records, big.mark = ",")`
:::::

```{r}
#| label: calculate-warnings

# Data quality checks
warnings <- list()

# Check panel coverage
panel_coverage <- uniqueN(panel_ids$local_id) / total_stations * 100
if (panel_coverage < 90) {
  warnings$panel <- paste0("Low panel ID coverage: ", round(panel_coverage, 1), "%")
}

# Check geocoding coverage
geocoding_rate <- geocoded_locais[, sum(!is.na(final_lat) & !is.na(final_long)) / .N * 100]
if (geocoding_rate < 95) {
  warnings$geocoding <- paste0("Geocoding coverage below 95%: ", round(geocoding_rate, 1), "%")
}

# Check municipality count
if (unique_municipalities > 5600) {
  warnings$muni_count <- paste0("Excessive municipality count: ", unique_municipalities, " (expected ~5,570)")
}

# Check for recent year data
if (!2024 %in% years_covered) {
  warnings$year <- "2024 data not found in dataset"
}
```

```{r}
#| label: display-warnings
#| results: asis

if (length(warnings) > 0) {
  cat("\n### ⚠️ Data Quality Warnings\n\n")
  for (w in warnings) {
    cat("- ", w, "\n")
  }
  cat("\n")
} else {
  cat("\n### ✅ All Quality Checks Passed\n\n")
}
```

## 1. Year-over-Year Polling Station Changes

```{r}
#| label: yoy-analysis

# Calculate year-over-year changes
yoy_summary <- geocoded_locais[, .(
  n_stations = uniqueN(local_id),
  n_with_coords = sum(!is.na(final_lat) & !is.na(final_long)),
  geocoding_rate = sum(!is.na(final_lat) & !is.na(final_long)) / .N * 100
), by = .(ano, sg_uf)][order(ano, sg_uf)]

# National level summary
national_summary <- geocoded_locais[, .(
  n_stations = uniqueN(local_id),
  n_records = .N,
  n_municipalities = uniqueN(cod_localidade_ibge)
), by = ano][order(ano)]

# Calculate changes
national_summary[, `:=`(
  stations_change = n_stations - shift(n_stations),
  pct_change = round((n_stations - shift(n_stations)) / shift(n_stations) * 100, 2),
  muni_change = n_municipalities - shift(n_municipalities)
)]
```

### National Trends

```{r}
#| label: national-trends-plot
#| fig-cap: "Number of polling stations over time"

ggplot(national_summary, aes(x = ano)) +
  geom_line(aes(y = n_stations), size = 1.2, color = colors["primary"]) +
  geom_point(aes(y = n_stations), size = 3, color = colors["primary"]) +
  geom_text(aes(y = n_stations, label = format(n_stations, big.mark = ",")), 
            vjust = -1, size = 3) +
  scale_x_continuous(breaks = years_covered) +
  scale_y_continuous(labels = scales::comma, expand = c(0.1, 0.1)) +
  labs(
    title = "Total Polling Stations by Year",
    x = "Year",
    y = "Number of Polling Stations"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
#| label: yoy-changes-table

# Create enhanced table with municipality counts
national_summary_display <- national_summary[, .(
  Year = ano,
  `Polling Stations` = format(n_stations, big.mark = ","),
  `Municipalities` = format(n_municipalities, big.mark = ","),
  `Station Change` = ifelse(is.na(stations_change), "--", 
                    paste0(ifelse(stations_change > 0, "+", ""), 
                           format(stations_change, big.mark = ","))),
  `% Change` = ifelse(is.na(pct_change), "--", 
                      paste0(ifelse(pct_change > 0, "+", ""), pct_change, "%"))
)]

datatable(
  national_summary_display,
  options = list(
    pageLength = 15,
    dom = 't',
    columnDefs = list(
      list(className = 'dt-center', targets = '_all')
    )
  ),
  rownames = FALSE,
  caption = "Year-over-Year Changes in Polling Station and Municipality Counts"
) %>%
  formatStyle(
    'Station Change',
    color = styleInterval(0, c('red', 'green')),
    fontWeight = 'bold'
  ) %>%
  formatStyle(
    '% Change',
    backgroundColor = styleInterval(
      c(-10, -5, 5, 10), 
      c('#ffcccc', '#ffe6cc', 'white', '#ccffcc', '#ff9999')
    )
  )
```

## 2. Municipality-Level Analysis (CORRECTED)

```{r}
#| label: municipality-analysis

# FIXED: Municipality-level summary using only code
muni_summary <- geocoded_locais[, .(
  n_stations = uniqueN(local_id),
  n_years = uniqueN(ano),
  first_year = min(ano),
  last_year = max(ano),
  n_names = uniqueN(nm_localidade),  # Count name variations
  names_used = paste(unique(nm_localidade), collapse = " | "),
  avg_geocoding = mean(!is.na(final_lat) & !is.na(final_long)) * 100
), by = cod_localidade_ibge]

# Add state info (most common state for each municipality)
state_info <- geocoded_locais[, .N, by = .(cod_localidade_ibge, sg_uf)][
  order(cod_localidade_ibge, -N)][
  , .SD[1], by = cod_localidade_ibge][
  , .(cod_localidade_ibge, sg_uf)]

muni_summary <- merge(muni_summary, state_info, by = "cod_localidade_ibge")

# Find municipalities with extreme changes
if (2022 %in% years_covered & 2024 %in% years_covered) {
  muni_2022 <- geocoded_locais[ano == 2022, .(
    n_2022 = uniqueN(local_id)
  ), by = cod_localidade_ibge]
  
  muni_2024 <- geocoded_locais[ano == 2024, .(
    n_2024 = uniqueN(local_id)
  ), by = cod_localidade_ibge]
  
  # FIXED: Merge by municipality code only
  muni_changes <- merge(muni_2022, muni_2024, 
                        by = "cod_localidade_ibge", 
                        all = TRUE)
  
  muni_changes[is.na(n_2022), n_2022 := 0]
  muni_changes[is.na(n_2024), n_2024 := 0]
  muni_changes[, `:=`(
    change = n_2024 - n_2022,
    pct_change = ifelse(n_2022 > 0, (n_2024 - n_2022) / n_2022 * 100, NA_real_)
  )]
  
  # Add municipality names from muni_summary
  muni_changes <- merge(muni_changes, 
                       muni_summary[, .(cod_localidade_ibge, names_used, sg_uf)], 
                       by = "cod_localidade_ibge", 
                       all.x = TRUE)
  
  extreme_changes <- muni_changes[abs(pct_change) > 30 & !is.na(pct_change)][order(-abs(pct_change))]
}
```

### Municipalities Overview (Corrected)

```{r}
#| label: muni-summary-stats

# Load reference municipality count
ref_muni_count <- 5570  # Known Brazilian municipality count
if (file.exists("data/muni_identifiers.csv")) {
  ref_munis <- fread("data/muni_identifiers.csv", encoding = "UTF-8")
  ref_muni_count <- nrow(ref_munis[existe == 1])
}

summary_stats <- data.table(
  Metric = c(
    "Total Unique Municipalities",
    "Expected Municipalities (IBGE)",
    "Municipality Count Discrepancy",
    "Average Stations per Municipality",
    "Municipalities with 100% Geocoding",
    "Municipalities Present All Years",
    "Municipalities with Name Variations"
  ),
  Value = c(
    format(nrow(muni_summary), big.mark = ","),
    format(ref_muni_count, big.mark = ","),
    sprintf("%+d", nrow(muni_summary) - ref_muni_count),
    round(mean(muni_summary$n_stations), 1),
    format(sum(muni_summary$avg_geocoding == 100), big.mark = ","),
    format(sum(muni_summary$n_years == length(years_covered)), big.mark = ","),
    format(sum(muni_summary$n_names > 1), big.mark = ",")
  )
)

kable(summary_stats, align = c("l", "r"))
```

### Municipality Name Variations

```{r}
#| label: name-variations
#| tbl-cap: "Examples of municipalities with multiple name variations"

name_variations <- muni_summary[n_names > 1][order(-n_names)][1:min(10, .N), .(
  `Muni Code` = cod_localidade_ibge,
  State = sg_uf,
  `# Names` = n_names,
  `Name Variations` = substr(names_used, 1, 80)
)]

if (nrow(name_variations) > 0) {
  datatable(
    name_variations,
    options = list(
      pageLength = 10,
      dom = 't'
    ),
    rownames = FALSE
  )
}
```

### Extreme Municipality Changes

```{r}
#| label: extreme-changes-table
#| tbl-cap: "Municipalities with Extreme Changes (>30% increase or decrease) from 2022 to 2024"

if (exists("extreme_changes") && nrow(extreme_changes) > 0) {
  extreme_display <- extreme_changes[1:min(20, .N), .(
    `Muni Code` = cod_localidade_ibge,
    Municipality = substr(names_used, 1, 30),
    State = sg_uf,
    `2022 Stations` = n_2022,
    `2024 Stations` = n_2024,
    `Change` = paste0(ifelse(change > 0, "+", ""), change),
    `% Change` = paste0(round(pct_change, 1), "%")
  )]
  
  datatable(
    extreme_display,
    options = list(
      pageLength = 10,
      columnDefs = list(
        list(className = 'dt-center', targets = 3:6)
      )
    ),
    rownames = FALSE
  ) %>%
    formatStyle(
      '% Change',
      color = styleInterval(c(-30, 30), c(colors["danger"], colors["warning"], colors["danger"])),
      fontWeight = 'bold'
    )
} else {
  cat("No extreme municipality changes detected or insufficient data for 2022-2024 comparison.")
}
```

## 3. Polling Station Persistence Analysis

```{r}
#| label: station-persistence

# Analyze local_id structure to understand persistence
sample_ids <- head(unique(geocoded_locais$local_id), 20)
id_contains_year <- any(grepl("2020|2022|2024|2006|2008|2010|2012|2014|2016|2018", sample_ids))

# Count stations by year presence
station_years <- geocoded_locais[, .(
  n_years = uniqueN(ano),
  years_present = paste(sort(unique(ano)), collapse = ","),
  n_records = .N
), by = local_id]

# Distribution of station persistence
persistence_dist <- station_years[, .N, by = n_years][order(n_years)]
```

### Local ID Structure Analysis

```{r}
#| label: id-structure

id_structure <- data.table(
  `Sample Local IDs` = sample_ids[1:min(10, length(sample_ids))],
  `Contains Year?` = grepl("20[0-2][0-9]", sample_ids[1:min(10, length(sample_ids))])
)

kable(id_structure, caption = "Sample local IDs and year detection")

cat("\n**Local ID Analysis:**\n")
cat(sprintf("- IDs appear to contain year: %s\n", ifelse(id_contains_year, "YES", "NO")))
cat(sprintf("- This explains why stations don't persist across years\n"))
```

### Station Persistence Distribution

```{r}
#| label: persistence-table

persistence_summary <- data.table(
  `Years Present` = persistence_dist$n_years,
  `Number of Stations` = format(persistence_dist$N, big.mark = ","),
  `Percentage` = paste0(round(persistence_dist$N / sum(persistence_dist$N) * 100, 1), "%")
)

kable(persistence_summary, 
      caption = "Distribution of polling stations by number of years present")

# Highlight the finding
if (sum(station_years$n_years == length(years_covered)) == 0) {
  cat("\n")
  cat("::::: {.callout-important}\n")
  cat("**Critical Finding**: Zero polling stations appear in all years.\n")
  cat("This is likely because `local_id` includes year-specific information.\n")
  cat(":::::\n")
}
```

## 4. Panel ID Quality Analysis (Corrected)

```{r}
#| label: panel-analysis

# Merge panel IDs with geocoded data to get temporal information
panel_temporal <- merge(
  geocoded_locais[, .(local_id, ano, cod_localidade_ibge, sg_uf)],
  panel_ids[, .(local_id, panel_id)],
  by = "local_id",
  all.x = TRUE
)

# Calculate panel longevity
panel_longevity <- panel_temporal[!is.na(panel_id), .(
  years_present = uniqueN(ano),
  first_year = min(ano),
  last_year = max(ano),
  years_list = paste(sort(unique(ano)), collapse = ","),
  states_present = uniqueN(sg_uf),
  municipalities = uniqueN(cod_localidade_ibge)
), by = panel_id]

# Categorize panel quality
max_years <- length(years_covered)
panel_longevity[, quality := fcase(
  years_present == max_years, "Complete",
  years_present >= max_years * 0.75, "High",
  years_present >= max_years * 0.5, "Medium",
  default = "Low"
)]
```

### Panel Coverage Statistics

```{r}
#| label: panel-coverage-stats

coverage_stats <- data.table(
  Metric = c(
    "Total Unique Panels",
    "Stations with Panel IDs",
    "Panel Coverage Rate",
    "Complete Panels (all years)",
    "High Quality Panels (≥75% years)",
    "Panels Spanning 2+ Years",
    "Panels Spanning Multiple States"
  ),
  Value = c(
    format(uniqueN(panel_ids$panel_id), big.mark = ","),
    format(uniqueN(panel_ids$local_id), big.mark = ","),
    paste0(round(uniqueN(panel_ids$local_id) / total_stations * 100, 1), "%"),
    format(sum(panel_longevity$quality == "Complete"), big.mark = ","),
    format(sum(panel_longevity$quality %in% c("Complete", "High")), big.mark = ","),
    format(sum(panel_longevity$years_present >= 2), big.mark = ","),
    format(sum(panel_longevity$states_present > 1), big.mark = ",")
  )
)

kable(coverage_stats, align = c("l", "r"))
```

### Panel Longevity Distribution

```{r}
#| label: panel-longevity-plot
#| fig-cap: "Distribution of panel longevity (years present in data)"

ggplot(panel_longevity, aes(x = years_present)) +
  geom_histogram(binwidth = 1, fill = colors["primary"], alpha = 0.8, color = "white") +
  geom_vline(xintercept = max_years * 0.75, linetype = "dashed", 
             color = colors["warning"], size = 1) +
  scale_x_continuous(breaks = 1:max_years) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Panel ID Longevity Distribution",
    subtitle = paste0("Dashed line indicates high quality threshold (", 
                      round(max_years * 0.75), "+ years)"),
    x = "Number of Years Present",
    y = "Number of Panels"
  ) +
  annotate("text", x = max_years, y = max(table(panel_longevity$years_present)) * 0.9,
           label = sprintf("%d panels\nspan all years", 
                          sum(panel_longevity$years_present == max_years)),
           hjust = 1, size = 4, color = colors["good"])
```

## 5. Data Quality Summary

```{r}
#| label: quality-summary

# Compile all quality metrics
quality_metrics <- list()

# Municipality count check
muni_discrepancy <- nrow(muni_summary) - ref_muni_count
quality_metrics$muni_count <- list(
  metric = "Municipality Count",
  value = nrow(muni_summary),
  threshold = ref_muni_count,
  status = ifelse(abs(muni_discrepancy) <= 50, "Pass", "Warning")
)

# Panel coverage
panel_coverage_val <- uniqueN(panel_ids$local_id) / total_stations * 100
quality_metrics$panel_coverage <- list(
  metric = "Panel ID Coverage",
  value = round(panel_coverage_val, 1),
  threshold = 90,
  status = ifelse(panel_coverage_val >= 90, "Pass", "Warning")
)

# Geocoding coverage
geocoding_rate_val <- geocoded_locais[, sum(!is.na(final_lat) & !is.na(final_long)) / .N * 100]
quality_metrics$geocoding <- list(
  metric = "Geocoding Coverage",
  value = round(geocoding_rate_val, 1),
  threshold = 95,
  status = ifelse(geocoding_rate_val >= 95, "Pass", "Warning")
)

# Temporal consistency
munis_all_years <- sum(muni_summary$n_years == length(years_covered))
quality_metrics$temporal <- list(
  metric = "Municipalities in All Years",
  value = munis_all_years,
  threshold = 5000,
  status = ifelse(munis_all_years >= 5000, "Pass", "Warning")
)
```

### Quality Metrics Dashboard

```{r}
#| label: quality-dashboard

# Create summary table
quality_df <- rbindlist(quality_metrics, idcol = "check")
quality_display <- quality_df[, .(
  Metric = metric,
  Value = ifelse(check %in% c("panel_coverage", "geocoding"), 
                 paste0(value, "%"), 
                 format(value, big.mark = ",")),
  Threshold = ifelse(check %in% c("panel_coverage", "geocoding"),
                     paste0(threshold, "%"),
                     format(threshold, big.mark = ",")),
  Status = status
)]

datatable(
  quality_display,
  options = list(
    pageLength = 10,
    dom = 't',
    columnDefs = list(
      list(className = 'dt-center', targets = 1:3)
    )
  ),
  rownames = FALSE,
  caption = "Data Quality Metrics Summary"
) %>%
  formatStyle(
    'Status',
    backgroundColor = styleEqual(
      c("Pass", "Warning"),
      c("#d4edda", "#fff3cd")
    ),
    fontWeight = 'bold'
  )
```

### Key Findings

```{r}
#| label: final-assessment
#| results: asis

cat("\n::: {.callout-note}\n")
cat("## Summary of Corrections\n\n")
cat("1. **Municipality Count**: Now correctly counts unique municipality codes only\n")
cat("2. **Temporal Analysis**: Based on municipality codes, not name combinations\n")
cat("3. **Station Persistence**: Identified that local_id likely contains year information\n")
cat("4. **Panel Coverage**: Correctly assesses panel IDs spanning multiple years\n")
cat(":::\n")

# Count warnings
n_warnings <- sum(sapply(quality_metrics, function(x) x$status == "Warning"))
n_checks <- length(quality_metrics)

if (n_warnings > 0) {
  cat("\n::: {.callout-warning}\n")
  cat("## ⚠️ Remaining Issues After Correction\n\n")
  
  for (metric in quality_metrics) {
    if (metric$status == "Warning") {
      cat(sprintf("- **%s**: %s (expected: %s)\n", 
                  metric$metric, 
                  ifelse(grepl("Coverage|%", metric$metric), 
                         paste0(metric$value, "%"), 
                         format(metric$value, big.mark = ",")),
                  ifelse(grepl("Coverage|%", metric$metric), 
                         paste0(metric$threshold, "%"), 
                         format(metric$threshold, big.mark = ","))))
    }
  }
  cat(":::\n")
}
```

---

<div style="text-align: center; color: #6c757d; font-size: 0.9em; margin-top: 50px;">
Report generated by the Brazilian Polling Station Geocoding Pipeline<br>
This is the corrected version using municipality codes instead of names<br>
`r R.version.string`
</div>